# 5.6 DB Schema 設計原則 (DB Schema Rules)

## 目的

本文件將「DB Schema 設計心得」整理為可執行的規則與檢查清單，目標是讓團隊在新增/調整資料表欄位時，能優先守住 **可維護性**、**一致性** 與 **SSOT (Single Source of Truth)**，避免為了 Query 方便而引入不可控的冗餘與維護成本。

---

## 核心主張（先決立場）

### 主張 1：可維護性 > Query 方便

- Schema 的第一優先是「長期一致」與「長期可演進」，不是「短期查詢好寫」。
- Query 的便利性應該以適當的 Index、查詢設計、或讀模型（Read Model）解決，而不是用冗餘欄位交換。

### 主張 2：拒絕冗餘，守護 SSOT

- 同一份資訊應只有一個權威來源（SSOT）。
- 任何冗餘欄位，都必須承擔「可能不一致」的風險，且這個風險會隨時間擴大。

### 主張 3：DB 存事實，程式負責解讀

- DB 的任務是保存「不可逆、不可失真」的原始事實（facts）。
- 可由事實推導出的解讀（interpretation）應由應用層負責，達到責任分離。

---

## 核心法則（最高優先）

### 核心問題：刪掉這個欄位，資訊會消失嗎？

- **不會消失** → **不該存在**（因為它可由其他欄位 100% 推導，是冗餘）。
- **會消失** → 才有資格進入下一輪評估（它可能是不可逆事實）。

---

## 規則 1：可 100% 推導的欄位，不要存

### ✅ 正確思維：只存 SSOT，推導交給應用層

情境：你已經有 `full_name = "openai/gpt-4"`，則 `owner` 可由 `full_name` 推導得到。

```python
class Repo:
    def __init__(self, full_name: str):
        self.full_name = full_name

    @property
    def owner(self) -> str:
        return self.full_name.split("/")[0]
```

### ❌ 錯誤做法：同時存 `full_name` 與 `owner`

- 當資料不一致（例如 `full_name` 改了、`owner` 沒改）時，只會增加維護成本與 debug 成本。
- 你會被迫回答「到底哪個欄位才是真的？」——這本質上就是 SSOT 破壞。

---

## 規則 2：Query 不該主導 Schema

### 常見迷思

- 「這樣查詢比較好寫，所以多存一個欄位吧。」

### ✅ 正確替代方案

- Query 方便性應由下列手段解決（按優先順序）：
  - **Index / Composite Index**（效能與可用性屬於 Index 的責任）
  - **Query/SQL 設計**（例如適當 join、適當 where 條件）
  - **專用讀模型（Read Model）或 Materialized View**（只要你願意把它當作衍生視圖/快取並建立同步策略）

### ❌ 不建議的交換

- 用冗餘欄位換「短期查詢好寫」：會讓 Schema 越來越像是「為了某些 Query 的偶發需求」堆疊而成，長期不可控。

---

## 規則 3：DB 只保存不可失真的事實（facts）

### ✅ 什麼是「事實」

- 不可逆、不可由其他欄位完全推導，且刪掉會造成資訊永久遺失的內容。

### ✅ 什麼是「解讀」

- 可從事實推導、可重算、或本質上屬於視角/呈現層的內容。
- 解讀應由應用層/服務層負責，避免 DB 變成「混合事實與解讀」的灰色地帶。

---

## 例外（有條件允許的冗餘）

此文件的預設立場是「拒絕冗餘」。但在以下情況，允許引入冗餘，前提是你必須明確承認它是 **衍生資料** 而不是 SSOT：

- **讀模型 / 快取表 / Materialized View**
  - 必須定義同步策略（何時重算、如何避免讀到不一致、壞掉如何修復）。
  - 必須定義「壞掉時以 SSOT 重建」的流程。
- **稽核/事件類資料（Audit/Event）**
  - 保存的是「當下發生的事實快照」（不可逆），不是為了 Query 方便而複製的欄位。

> 原則不變：**一旦你承認它是衍生資料，就不能把它當 SSOT 使用。**

---

## 快速檢查清單（新增欄位前必問）

- [ ] **刪掉這個欄位，資訊會消失嗎？**
- [ ] **它是否可由其他欄位 100% 推導？**（是 → 不該存）
- [ ] **它是否會破壞 SSOT？**（同一概念出現兩份來源）
- [ ] **它是否只為了 Query 方便？**（是 → 先用 Index / Query / Read Model 解）
- [ ] **如果這是冗餘/讀模型：同步與重建策略是否被明確定義？**
- [ ] **你是否能清楚指出「哪個欄位/表」才是 SSOT？**

---

## 結論

資料庫的任務是保存不可失真的事實，而不是讓 Query 比較好寫。  
設計思維的關鍵，在於對一致性的堅持。

